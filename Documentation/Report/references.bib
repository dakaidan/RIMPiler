@misc{RegexDisambiguationAutomata,
  title = {Disambiguation in {{Regular Expression Matching}} via {{Position Automata}} with {{Augmented Transitions}} | {{SpringerLink}}},
  urldate = {2023-12-11},
  howpublished = {https://link.springer.com/chapter/10.1007/978-3-642-18098-9\_25},
}

@inproceedings{LexerGenerator,
  title = {Verbatim: {{A Verified Lexer Generator}}},
  shorttitle = {Verbatim},
  booktitle = {2021 {{IEEE Security}} and {{Privacy Workshops}} ({{SPW}})},
  author = {Egolf, Derek and Lasser, Sam and Fisher, Kathleen},
  year = {2021},
  month = may,
  pages = {92--100},
  doi = {10.1109/SPW53761.2021.00022},
  urldate = {2023-12-11},
  abstract = {Lexers and parsers are often used as front ends to connect input from the outside world with th e internals of a larger software system. These front ends are natural targets for attackers who w ish to compromise the larger system. A formally verified tool that p erforms mechanized lexical analysis would render attacks on these front ends less effective. In this paper we present Verbatim, an executable lexer that is implemented and verified with th e Coq P ro o f Assistant. We prove that Verbatim is correct with respect to a standard lexer specification. We also analyze its theoretical com plexity and give results o f an em pirical performance evaluation. All correctness proofs have been mechanized in Coq.},
}

@inproceedings{RegexMatchingAutomata,
  title = {Greedy {{Regular Expression Matching}}},
  booktitle = {Automata, {{Languages}} and {{Programming}}},
  author = {Frisch, Alain and Cardelli, Luca},
  editor = {D{\'i}az, Josep and Karhum{\"a}ki, Juhani and Lepist{\"o}, Arto and Sannella, Donald},
  year = {2004},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {618--629},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-540-27836-8_53},
  abstract = {This paper studies the problem of matching sequences against regular expressions in order to produce structured values.},
  isbn = {978-3-540-27836-8},
  langid = {english},
  keywords = {Abstract Syntax Tree,Input Word,Pattern Match,Regular Expression,Syntax Tree}
}

@article{Hermes,
  title = {Hermes: {{A}} Reversible Language for Lightweight Encryption},
  shorttitle = {Hermes},
  author = {Mogensen, Torben {\AE}gidius},
  year = {2022},
  month = mar,
  journal = {Science of Computer Programming},
  volume = {215},
  pages = {102746},
  issn = {0167-6423},
  doi = {10.1016/j.scico.2021.102746},
  urldate = {2023-12-10},
  abstract = {Hermes is a domain-specific language for writing lightweight encryption algorithms: It is reversible, so it is not necessary to write separate encryption and decryption procedures. Hermes uses a type system that avoids several types of side-channel attacks, by ensuring no secret values are left in memory and that operations on secret data spend time independent of the value of this data, thus preventing timing-based attacks. We show a complete formal specification of Hermes, argue absence of timing-based attacks (under reasonable assumptions), and compare implementations of well-known lightweight encryption algorithms in Hermes and C.},
  keywords = {Domain-specific languages,Lightweight encryption,Reversible programming languages,Side-channel attacks},
  file = {/home/aidan/Zotero/storage/YEQM89PU/S0167642321001398.html}
}

@book{IntroductionToReversibleComputing,
  title = {Introduction to {{Reversible Computing}}},
  author = {Perumalla, Kalyan S.},
  year = {2013},
  month = sep,
  publisher = {{CRC Press}},
  abstract = {Few books comprehensively cover the software and programming aspects of reversible computing. Filling this gap, Introduction to Reversible Computing offers an expanded view of the field that includes the traditional energy-motivated hardware viewpoint as well as the emerging application-motivated software approach.   Collecting scattered knowledge into one coherent account, the book provides a compendium of both classical and recently developed results on reversible computing. It explores up-and-coming theories, techniques, and tools for the application of reversible computing{\textemdash}the logical next step in the evolution of computing systems.  The book covers theory, hardware and software aspects, fundamental limits, complexity analyses, practical algorithms, compilers, efficiency improvement techniques, and application areas. The topics span several areas of computer science, including high-performance computing, parallel/distributed systems, computational theory, compilers, power-aware computing, and supercomputing.   The book presents sufficient material for newcomers to easily get started. It provides citations to original articles on seminal results so that readers can consult the corresponding publications in the literature. Pointers to additional resources are included for more advanced topics. For those already familiar with a certain topic within reversible computing, the book can serve as a one-stop reference to other topics in the field.},
  googlebooks = {HUrGAAAAQBAJ},
  isbn = {978-1-4398-7340-3},
  langid = {english},
  keywords = {Computers / General,Computers / Hardware / Mainframes \& Minicomputers,Computers / Programming / Algorithms,Mathematics / Advanced,Mathematics / Arithmetic,Mathematics / Number Systems}
}

@misc{JanusFormalised,
  title = {A Reversible Programming Language and Its Invertible Self-Interpreter | {{Proceedings}} of the 2007 {{ACM SIGPLAN}} Symposium on {{Partial}} Evaluation and Semantics-Based Program Manipulation},
  urldate = {2023-12-01},
  howpublished = {https://dl.acm.org/doi/abs/10.1145/1244381.1244404?casa\_token=XryEDw6Gc10AAAAA:OoWNPXcs\_rfAYsR9L4hzAmDt7BWbWUIF5Ph5KLrOVoEa7u6QYTlZOzLD2SNneaIz0BABNI-1byljnw},
  file = {/home/aidan/Zotero/storage/UNM9UBY3/1244381.html}
}

@unpublished{JanusLetter,
  type = {Letter},
  title = {{{JANUS}}: {{A Time-Reversible Language}}},
  author = {Christopher, Lutz},
  year = {1986},
  month = apr,
  urldate = {2023-12-01}
}

@inproceedings{JanusToRSSA,
  title = {Compiling {{Janus}} to {{RSSA}}},
  booktitle = {Reversible {{Computation}}},
  author = {Kutrib, Martin and Meyer, Uwe and Deworetzki, Niklas and Schuster, Marc},
  editor = {Yamashita, Shigeru and Yokoyama, Tetsuo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {64--78},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-79837-6_4},
  abstract = {Reversible programming languages have been a focus of research for more than the last decade mostly due to the work of Gl{\"u}ck, Yokoyama, Mogensen, and many others. In this paper, we report about our recent activities to compile code written in the reversible language Janus to reversible static-single-assignment form RSSA and to three-address-code, both of which can thereafter be compiled to C. In particular, this is {\textendash} to our knowledge {\textendash} the first compiler from Janus to RSSA. In addition, we have implemented a novel technique for a reversible compiler by executing the code generator itself in reverse. Our compiler provides the basis for optimizations and further analysis of reversible programs.},
  isbn = {978-3-030-79837-6},
  langid = {english},
  keywords = {Janus,Reverse computing,Reversible programming languages,Reversible static-single-assignment}
}

@article{knuthTranslationLanguagesLeft1965,
  title = {On the Translation of Languages from Left to Right},
  author = {Knuth, Donald E.},
  year = {1965},
  month = dec,
  journal = {Information and Control},
  volume = {8},
  number = {6},
  pages = {607--639},
  issn = {0019-9958},
  doi = {10.1016/S0019-9958(65)90426-2},
  urldate = {2023-12-11},
  abstract = {There has been much recent interest in languages whose grammar is sufficiently simple that an efficient left-to-right parsing algorithm can be mechanically produced from the grammar. In this paper, we define LR(k) grammars, which are perhaps the most general ones of this type, and they provide the basis for understanding all of the special tricks which have been used in the construction of parsing algorithms for languages with simple structure, e.g. algebraic languages. We give algorithms for deciding if a given grammar satisfies the LR(k) condition, for given k, and also give methods for generating recognizes for LR(k) grammars. It is shown that the problem of whether or not a grammar is LR(k) for some k is undecidable, and the paper concludes by establishing various connections between LR(k) grammars and deterministic languages. In particular, the LR(k) condition is a natural analogue, for grammars, of the deterministic condition, for languages.},
}

@article{LexingDerivatives,
  title = {{{POSIX Lexing}} with {{Derivatives}} of {{Regular Expressions}}},
  author = {Urban, Christian},
  year = {2023},
  month = jul,
  journal = {Journal of Automated Reasoning},
  volume = {67},
  number = {3},
  pages = {24},
  issn = {1573-0670},
  doi = {10.1007/s10817-023-09667-1},
  urldate = {2023-12-10},
  abstract = {Brzozowski introduced the notion of derivatives for regular expressions. They can be used for a very simple regular expression matching algorithm. Sulzmann and Lu cleverly extended this algorithm in order to deal with POSIX matching, which is the underlying disambiguation strategy for regular expressions needed in lexers. Their algorithm generates POSIX values which encode the information of how a regular expression matches a string{\textemdash}that is, which part of the string is matched by which part of the regular expression. In this paper we give our inductive definition of what a POSIX value is and show that Sulzmann and Lu's algorithm always generates such a value. We also show that our inductive definition of a POSIX value is equivalent to an alternative definition by Okui and Suzuki which identifies POSIX values as least elements according to an ordering of values.},
  langid = {english},
  keywords = {Derivatives of Regular Expressions,Isabelle/HOL,POSIX matching},
  file = {/home/aidan/Zotero/storage/JQ8ZHLDG/Urban - 2023 - POSIX Lexing with Derivatives of Regular Expressio.pdf}
}

@article{LogicalReversibilityOfComputation,
  title = {Logical {{Reversibility}} of {{Computation}}},
  author = {Bennett, C. H.},
  year = {1973},
  month = nov,
  journal = {IBM Journal of Research and Development},
  volume = {17},
  number = {6},
  pages = {525--532},
  issn = {0018-8646},
  doi = {10.1147/rd.176.0525},
  urldate = {2023-12-01},
  abstract = {The usual general-purpose computing automaton (e.g., a Turing machine) is logically irreversible{\textemdash}its transition function lacks a single-valued inverse. Here it is shown that such machines may be made logically reversible at every step, while retaining their simplicity and their ability to do general computations. This result is of great physical interest because it makes plausible the existence of thermodynamically reversible computers which could perform useful computations at useful speed while dissipating considerably less than kT of energy per logical step. In the first stage of its computation the logically reversible automaton parallels the corresponding irreversible automaton, except that it saves all intermediate results, thereby avoiding the irreversible operation of erasure. The second stage consists of printing out the desired output. The third stage then reversibly disposes of all the undesired intermediate results by retracing the steps of the first stage in backward order (a process which is only possible because the first stage has been carried out reversibly), thereby restoring the machine (except for the now-written output tape) to its original condition. The final machine configuration thus contains the desired output and a reconstructed copy of the input, but no other undesired data. The foregoing results are demonstrated explicitly using a type of three-tape Turing machine. The biosynthesis of messenger RNA is discussed as a physical example of reversible computation.},
  file = {/home/aidan/Zotero/storage/QCI6VYI7/5391327.html}
}

@misc{NFAConstruction,
  title = {Gluskov and {{Thompson}} Constructions : A Synthesis},
  shorttitle = {Gluskov and {{Thompson}} Constructions},
  author = {Giammarresi, Dora},
  year = {1998},
  langid = {english}
}

@inproceedings{okuiDisambiguationRegularExpression2011,
  title = {Disambiguation in {{Regular Expression Matching}} via {{Position Automata}} with {{Augmented Transitions}}},
  booktitle = {Implementation and {{Application}} of {{Automata}}},
  author = {Okui, Satoshi and Suzuki, Taro},
  editor = {Domaratzki, Michael and Salomaa, Kai},
  year = {2011},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {231--240},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-18098-9_25},
  abstract = {This paper offers a new efficient regular expression matching algorithm which follows the POSIX-type leftmost-longest rule. The algorithm basically emulates the subset construction without backtracking, so that its computational cost even in the worst case does not explode exponentially; the time complexity of the algorithm is O(mn(n\,+\,c)), where m is the length of a given input string, n the number of occurrences of the most frequently used letter in a given regular expression and c the number of subexpressions to be used for capturing substrings. A formalization of the leftmost-longest semantics by using parse trees is also discussed.},
  isbn = {978-3-642-18098-9},
  langid = {english}
}

@inproceedings{OptimiseReversiblePrograms,
  title = {Optimizing {{Reversible Programs}}},
  booktitle = {Reversible {{Computation}}},
  author = {Deworetzki, Niklas and Kutrib, Martin and Meyer, Uwe and Ritzke, Pia-Doreen},
  editor = {Mezzina, Claudio Antares and Podlaski, Krzysztof},
  year = {2022},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {224--238},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-031-09005-9_16},
  abstract = {Reversible programming languages have been a focus of research for more than the last decade mostly due to the work of Gl{\"u}ck, Yokoyama, Mogensen, and many others. In this paper we report about our recent activities to optimize reversible code with respect to execution time. Based on our rc3-compiler which compiles Janus to reversible static-single-assignment form RSSA, we had explored and implemented optimization algorithms for local common-subexpression elimination, constant propagation, and folding and have presented those at SOAP 2021. This paper focuses on new achievements for procedure inlining as well as elimination of dead code. Our compiler is{\textemdash}to our knowledge{\textemdash}the first optimizing compiler for reversible languages. Whereas these optimizations are well established for ``traditional'' languages, programs that can be executed forwards and backwards require different and novel approaches.},
  isbn = {978-3-031-09005-9},
  langid = {english},
  keywords = {Janus,Optimization,Reverse computing,Reversible programming languages,Reversible static-single-assignment},
  file = {/home/aidan/Zotero/storage/UAT7QD5I/Deworetzki et al. - 2022 - Optimizing Reversible Programs.pdf}
}

@inproceedings{paoliniCertifiedStudyReversible2018,
  title = {A {{Certified Study}} of a {{Reversible Programming Language}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{TYPES}}.2015.7},
  author = {Paolini, Luca and Piccolo, Mauro and Roversi, Luca},
  year = {2018},
  publisher = {{Schloss-Dagstuhl - Leibniz Zentrum f{\"u}r Informatik}},
  doi = {10.4230/LIPIcs.TYPES.2015.7},
  urldate = {2023-12-10},
  abstract = {We advance in the study of the semantics of Janus, a C-like reversible programming language.  Our study makes utterly explicit some backward and forward evaluation symmetries. We want to deepen mathematical knowledge about the foundations and design principles of reversible computing and programming languages. We formalize a big-step operational semantics and a denotational semantics of Janus. We show a full abstraction result between the operational and denotational semantics. Last, we certify our results by means of the proof assistant Matita.},
  copyright = {https://creativecommons.org/licenses/by/3.0/legalcode},
  langid = {english},
  file = {/home/aidan/Zotero/storage/4IAT99X8/Paolini et al. - 2018 - A Certified Study of a Reversible Programming Lang.pdf}
}

@incollection{PISA,
  title = {Reversible {{Machine Code}} and {{Its Abstract Processor Architecture}}},
  booktitle = {Computer {{Science}} {\textendash} {{Theory}} and {{Applications}}},
  author = {Axelsen, Holger Bock and Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
  editor = {Diekert, Volker and Volkov, Mikhail V. and Voronkov, Andrei},
  year = {2007},
  volume = {4649},
  pages = {56--69},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-74510-5_9},
  urldate = {2023-12-01},
  abstract = {A reversible abstract machine architecture and its reversible machine code are presented and formalized. For machine code to be reversible, both the underlying control logic and each instruction must be reversible. A general class of machine instruction sets was proven to be reversible, building on our concept of reversible updates. The presentation is abstract and can serve as a guideline for a family of reversible processor designs. By example, we illustrate programming principles for the abstract machine architecture formalized in this paper.},
  isbn = {978-3-540-74509-9 978-3-540-74510-5},
  langid = {english},
  file = {/home/aidan/Zotero/storage/LWZ2NNAH/Axelsen et al. - 2007 - Reversible Machine Code and Its Abstract Processor.pdf}
}

@inproceedings{PrattParsing,
  title = {Top down Operator Precedence},
  booktitle = {Proceedings of the 1st Annual {{ACM SIGACT-SIGPLAN}} Symposium on {{Principles}} of Programming Languages  - {{POPL}} '73},
  author = {Pratt, Vaughan R.},
  year = {1973},
  pages = {41--51},
  publisher = {{ACM Press}},
  address = {{Boston, Massachusetts}},
  doi = {10.1145/512927.512931},
  urldate = {2023-12-10},
  langid = {english},
  file = {/home/aidan/Zotero/storage/QAYNRN4Q/Pratt - 1973 - Top down operator precedence.pdf}
}

@inproceedings{PrinciplesOfReversibleProgrammingLanguage,
  title = {Principles of a Reversible Programming Language},
  booktitle = {Proceedings of the 5th Conference on {{Computing}} Frontiers},
  author = {Yokoyama, Tetsuo and Axelsen, Holger Bock and Gl{\"u}ck, Robert},
  year = {2008},
  month = may,
  series = {{{CF}} '08},
  pages = {43--54},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1366230.1366239},
  urldate = {2023-12-10},
  abstract = {The principles of reversible programming languages are explicated and illustrated with reference to the design of a high-level imperative language, Janus. The fundamental properties for such languages include backward as well as forward determinism and reversible updates of data. The unique design features of the language include explicit post-condition assertions, direct access to an inverse semantics and the possibility of clean (\{{\textbackslash}ie\}, garbage-free) computation of injective functions. We suggest the clean simulation of reversible Turing machines as a criterion for computing strength of reversible languages, and demonstrate this for Janus. We show the practicality of the language by implementation of a reversible fast Fourier transform. Our results indicate that the reversible programming paradigm has fundamental properties that are relevant to many different areas of computer science.},
  isbn = {978-1-60558-077-7},
  keywords = {backward determinism,fast fourier transform,inverse semantics,reversible computing,turing completeness}
}

@article{ReversibilityWithMinimalData,
  title = {Making {{Programs Reversible}} with {{Minimal Extra Data}}},
  author = {Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
  year = {2022},
  month = jul,
  journal = {New Generation Computing},
  volume = {40},
  number = {2},
  pages = {467--480},
  issn = {1882-7055},
  doi = {10.1007/s00354-022-00169-z},
  urldate = {2023-12-10},
  abstract = {Reversible computing is an unconventional computing paradigm that comes with specific challenges. One of the important questions is the existence of reversible programs with minimal extra output (garbage data). To answer this question for programs that implement partial functions over countable domains, we introduce an order on infinite garbage sets and a notion of minimality. To this end, we present two methods for functions specified by decidable and semi-decidable predicates. Both methods are universal, which means they work for all programs specified by the predicates. They cover Bennett's classic input-erasing reversible computation of injective functions. Hence, any program written in a Turing-complete programming language can be implemented with g-minimal garbage in an r-Turing-complete reversible programming language. This generality comes at the cost of a considerable runtime due to the generate-and-test approach.},
  langid = {english},
  keywords = {68Q30,68W40,Garbage data,Injectivization,Reversibilization,Reversible computing,Reversible programming}
}

@inproceedings{ReversibleArrayProgramming,
  title = {Reversible {{Functional Array Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {Mogensen, Torben {\AE}gidius},
  editor = {Yamashita, Shigeru and Yokoyama, Tetsuo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {45--63},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-79837-6_3},
  abstract = {Functional array programming is a style of programming that enables massive parallelism through use of combinators (such as map and reduce) that apply functions to whole arrays. These can be readily parallelised when the functions these combinators are applied to are pure and, in some cases, also associative.},
  isbn = {978-3-030-79837-6},
  langid = {english}
}

@misc{ReversibleMachineCode,
  title = {Reversible {{Machine Code}} and {{Its Abstract Processor Architecture}} | {{SpringerLink}}},
  urldate = {2023-12-10},
  howpublished = {https://link.springer.com/chapter/10.1007/978-3-540-74510-5\_9},
  file = {/home/aidan/Zotero/storage/EMAKBMLX/978-3-540-74510-5_9.html}
}

@article{ReversibleMetalanguages,
  title = {From Reversible Programming Languages to Reversible Metalanguages},
  author = {Gl{\"u}ck, Robert and Kaarsgaard, Robin and Yokoyama, Tetsuo},
  year = {2022},
  month = jun,
  journal = {Theoretical Computer Science},
  volume = {920},
  pages = {46--63},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2022.02.024},
  urldate = {2023-12-10},
  abstract = {During the past decade reversible programming languages have been formalized using various established semantics frameworks. However, these semantics fail to effectively specify the distinct properties of reversible languages at the metalevel, even including the central question of whether the defined language is reversible. In this paper, we build a metalanguage foundation for reversible languages from categorical principles, based on the category of sets and partial injective functions. We exemplify our approach by a step-by-step development of the full semantics of an r-Turing complete reversible while-language with recursive procedures. The use of the metalanguage leads to a formalization of the reversible semantics. A language defined in the metalanguage is guaranteed to have reversibility and inverse semantics. Also, program inverters for this language are obtained for free. We further discuss applications and directions for reversible semantics.},
  keywords = {Formal semantics,Iteration,Partial injective functions,Recursion,Reversible programming},
  file = {/home/aidan/Zotero/storage/EXQ2B5SJ/S0304397522001116.html}
}

@inproceedings{ReversiblePrologDebugger,
  title = {Reversible {{Computations}} in {{Logic Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {Vidal, Germ{\'a}n},
  editor = {Lanese, Ivan and Rawski, Mariusz},
  year = {2020},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {246--254},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-52482-1_15},
  abstract = {In this work, we say that a computation is reversible if one can find a procedure to undo the steps of a standard (or forward) computation in a deterministic way. While logic programs are often invertible (e.g., one can use the same predicate for adding and for subtracting natural numbers), computations are not reversible in the above sense. In this paper, we present a so-called Landauer embedding for SLD resolution, the operational principle of logic programs, so that it becomes reversible. A proof-of-concept implementation of a reversible debugger for Prolog that follows the ideas in this paper has been developed and is publicly available.},
  isbn = {978-3-030-52482-1},
  langid = {english},
  file = {/home/aidan/Zotero/storage/JSJJGNBX/Vidal - 2020 - Reversible Computations in Logic Programming.pdf}
}

@inproceedings{RFun,
  title = {Interpretation and Programming of the Reversible Functional Language {{RFUN}}},
  booktitle = {Proceedings of the 27th {{Symposium}} on the {{Implementation}} and {{Application}} of {{Functional Programming Languages}}},
  author = {Thomsen, Michael Kirkedal and Axelsen, Holger Bock},
  year = {2015},
  month = sep,
  series = {{{IFL}} '15},
  pages = {1--13},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2897336.2897345},
  urldate = {2023-12-10},
  abstract = {rfun is a small first-order reversible functional language introduced by Yokoyama et al. in 2012. The present paper aims to further the understanding of reversible functional programming (and RFUN in particular) by describing implementations in, and of, the RFUN language. After briefly summarizing rfun in terms of syntax and semantics, we first (informally) describe a transformation from the simple irreversible first-order language fun to rfun. This highlights how irreversibility is avoided in rfun, such as in the use of the so-called first-match policy. It also emphasizes the fact that rfun is trace-less, while also showing how the standard reversible (trace-full) embeddings of Landauer and Bennett can be implemented. Second, we outline (by examples) a number of the reversible functions that have been implemented in rfun. The programming examples given here focus on Peano arithmetic and list functions, and are intended to show various useful programming techniques of the reversible functional programming paradigm. Finally, we discuss the implementation of rfun. This is twofold as we relate a Haskell implementation of an rfun interpreter, to an implementation of a self-interpreter, i.e., an rfun interpreter implemented in rfun. Although rfun does not have the rich and expressive syntax of Haskell---which makes programming the self-interpreter more cumbersome in some aspects---the built-in support for reverse execution greatly reduces the code base and makes the rfun-based self-interpreter implementation follow the formal semantics of rfun more directly than the Haskell-based interpreter.},
  isbn = {978-1-4503-4273-5},
  keywords = {functional programming languages,program transformation,reversibilization,reversible computing,reversible functional programming,self-interpretation}
}

@book{richardpFeynmanLecturesComputation2018,
  title = {Feynman Lectures on Computation},
  author = {Richard P, Feynman},
  year = {2018},
  publisher = {{CRC Press}}
}

@inproceedings{RIMP,
  title = {A {{Reversible Operational Semantics}} for {{Imperative Programming Languages}}},
  booktitle = {Formal {{Methods}} and {{Software Engineering}}},
  author = {Fern{\'a}ndez, Maribel and Mackie, Ian},
  editor = {Lin, Shang-Wei and Hou, Zhe and Mahony, Brendan},
  year = {2020},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {91--106},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-63406-3_6},
  abstract = {Imperative programming languages are not reversible in general; however, there are well-known approaches to make them reversible, e.g., by storing computation histories or checkpointing. Another successful approach is based on designing restricted languages where all the commands are reversible (cf. Janus, R-WHILE). We present an alternative approach where we do not restrict the language. Instead, we modify the operational semantics (while preserving the meaning of programs) to obtain reversibility at both language level and computation level.},
  isbn = {978-3-030-63406-3},
  langid = {english},
  keywords = {Imperative programming,Language-level reversibility,Reversible computation steps,Universal languages},
  file = {/home/aidan/Zotero/storage/3AMELDKP/Fern√°ndez and Mackie - 2020 - A Reversible Operational Semantics for Imperative .pdf}
}

@inproceedings{ROOP,
  title = {Towards a {{Unified Language Architecture}} for {{Reversible Object-Oriented Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {{Hay-Schmidt}, Lasse and Gl{\"u}ck, Robert and Cservenka, Martin Holm and Haulund, Tue},
  editor = {Yamashita, Shigeru and Yokoyama, Tetsuo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {96--106},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-79837-6_6},
  abstract = {A unified language architecture for an advanced reversible object-oriented language is described. The design and implementation choices made for a tree-walking interpreter and source-language inverter are discussed, as well as the integration with an existing monadic parser, type checker and PISA compiler backend. A demonstration of the web interface and the interactions required to interpret, compile and invert reversible object-oriented programs is given. Our aim is that this platform will make reversible programming approachable to a wider community.},
  isbn = {978-3-030-79837-6},
  langid = {english},
  file = {/home/aidan/Zotero/storage/SZWDETD3/Hay-Schmidt et al. - 2021 - Towards a Unified Language Architecture for Revers.pdf}
}

@misc{ROOPImplementation,
  title = {Design and {{Implementation}} of a {{Reversible Object-Oriented Programming Language}}},
  author = {Haulund, Tue},
  year = {2017},
  month = jul,
  number = {arXiv:1707.07845},
  eprint = {1707.07845},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.1707.07845},
  urldate = {2023-12-01},
  abstract = {High-level reversible programming languages are few and far between and in general offer only rudimentary abstractions from the details of the underlying machine. Modern programming languages offer a wide array of language constructs and paradigms to facilitate the design of abstract interfaces, but we currently have a very limited understanding of the applicability of such features for reversible programming languages. We introduce the first reversible object-oriented programming language, ROOPL, with support for user-defined data types, class inheritance and subtype-polymorphism. The language extends the design of existing reversible imperative languages and it allows for effective implementation on reversible machines. We provide a formalization of the language semantics, the type system and we demonstrate the computational universality of the language by implementing a reversible Turing machine simulator. ROOPL statements are locally invertible at no extra cost to program size or computational complexity and the language provides direct access to the inverse semantics of each class method. We describe the techniques required for a garbage-free translation from ROOPL to the reversible assembly language PISA and provide a full implementation of said techniques. Our results indicate that core language features for object-oriented programming carries over to the field of reversible computing in some capacity.},
  archiveprefix = {arxiv},
  keywords = {68N15,Computer Science - Programming Languages,D.3.2,D.3.3,D.3.4},
  file = {/home/aidan/Zotero/storage/Y5FUQRGV/Haulund - 2017 - Design and Implementation of a Reversible Object-O.pdf;/home/aidan/Zotero/storage/7IB4869W/1707.html}
}

@inproceedings{RSSA,
  title = {{{RSSA}}: {{A Reversible SSA Form}}},
  shorttitle = {{{RSSA}}},
  booktitle = {Perspectives of {{System Informatics}}},
  author = {Mogensen, Torben {\AE}gidius},
  editor = {Mazzara, Manuel and Voronkov, Andrei},
  year = {2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {203--217},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-41579-6_16},
  abstract = {The SSA form (Static Single Assignment form) is used in compilers as an intermediate language as an alternative to traditional three-address code because code in SSA form is easier to analyse and optimize using data-flow analysis such as common-subexpression elimination, value numbering, register allocation and so on.},
  isbn = {978-3-319-41579-6},
  langid = {english},
  keywords = {Basic Block,Constant Propagation,Entry Point,Exit Point,Result List},
  file = {/home/aidan/Zotero/storage/UIIC2TDU/Mogensen - 2016 - RSSA A Reversible SSA Form.pdf}
}

@inproceedings{SSA,
  title = {Global Value Numbers and Redundant Computations},
  booktitle = {Proceedings of the 15th {{ACM SIGPLAN-SIGACT}} Symposium on {{Principles}} of Programming Languages},
  author = {Rosen, B. K. and Wegman, M. N. and Zadeck, F. K.},
  year = {1988},
  month = jan,
  series = {{{POPL}} '88},
  pages = {12--27},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/73560.73562},
  urldate = {2023-12-10},
  isbn = {978-0-89791-252-5},
  file = {/home/aidan/Zotero/storage/ZVJGNFT4/Rosen et al. - 1988 - Global value numbers and redundant computations.pdf}
}

@article{SSAConstruction,
  title = {Algorithms for Computing the Static Single Assignment Form},
  author = {Bilardi, Gianfranco and Pingali, Keshav},
  year = {2003},
  month = may,
  journal = {Journal of the ACM},
  volume = {50},
  number = {3},
  pages = {375--425},
  issn = {0004-5411},
  doi = {10.1145/765568.765573},
  urldate = {2023-12-10},
  abstract = {The Static Single Assignment (SSA) form is a program representation used in many optimizing compilers. The key step in converting a program to SSA form is called {$\phi$}-placement. Many algorithms for {$\phi$}-placement have been proposed in the literature, but the relationships between these algorithms are not well understood.In this article, we propose a framework within which we systematically derive (i) properties of the SSA form and (ii) {$\phi$}-placement algorithms. This framework is based on a new relation called merge which captures succinctly the structure of a program's control flow graph that is relevant to its SSA form. The {$\phi$}-placement algorithms we derive include most of the ones described in the literature, as well as several new ones. We also evaluate experimentally the performance of some of these algorithms on the SPEC92 benchmarks.Some of the algorithms described here are optimal for a single variable. However, their repeated application is not necessarily optimal for multiple variables. We conclude the article by describing such an optimal algorithm, based on the transitive reduction of the merge relation, for multi-variable {$\phi$}-placement in structured programs. The problem for general programs remains open.},
  keywords = {Control dependence,optimizing compilers,program optimization,program transformation,static single assignment form},
  file = {/home/aidan/Zotero/storage/AGGJE6JY/Bilardi and Pingali - 2003 - Algorithms for computing the static single assignm.pdf}
}

@incollection{SSAFromAST,
  title = {Simple and {{Efficient Construction}} of {{Static Single Assignment Form}}},
  booktitle = {Compiler {{Construction}}},
  author = {Braun, Matthias and Buchwald, Sebastian and Hack, Sebastian and Lei{\ss}a, Roland and Mallon, Christoph and Zwinkau, Andreas},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Jhala, Ranjit and De Bosschere, Koen},
  year = {2013},
  volume = {7791},
  pages = {102--122},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-37051-9_6},
  urldate = {2023-12-01},
  abstract = {We present a simple SSA construction algorithm, which allows direct translation from an abstract syntax tree or bytecode into an SSA-based intermediate representation. The algorithm requires no prior analysis and ensures that even during construction the intermediate representation is in SSA form. This allows the application of SSA-based optimizations during construction. After completion, the intermediate representation is in minimal and pruned SSA form. In spite of its simplicity, the runtime of our algorithm is on par with Cytron et al.'s algorithm.},
  isbn = {978-3-642-37050-2 978-3-642-37051-9},
  langid = {english},
  file = {/home/aidan/Zotero/storage/Y3JU7XAD/Braun et al. - 2013 - Simple and Efficient Construction of Static Single.pdf}
}

@incollection{sulzmannFlexibleEfficientML2014,
  title = {A {{Flexible}} and {{Efficient ML Lexer Tool Based}} on {{Extended Regular Expression Submatching}}},
  booktitle = {Compiler {{Construction}}},
  author = {Sulzmann, Martin and Van Steenhoven, Pippijn},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Cohen, Albert},
  year = {2014},
  volume = {8409},
  pages = {174--191},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-54807-9_10},
  urldate = {2023-12-11},
  abstract = {Lexical analysis has many applications beyond the first phase of compilation in programming language processing. We argue that extended regular expressions combined with the ability to extract submatch information significantly increase the expressiveness of lexer specifications. We show that such an expressive lexical analysis can be done efficiently using some novel automata-based methods. The approach has been implemented in an ML lexer tool which is compatible with ocamllex. Experimental results confirm that our approach is competitive with respect to existing ML lexer tools.},
  isbn = {978-3-642-54806-2 978-3-642-54807-9},
  langid = {english},
  file = {/home/aidan/Zotero/storage/3A39Z6XY/Sulzmann and Van Steenhoven - 2014 - A Flexible and Efficient ML Lexer Tool Based on Ex.pdf}
}

@article{Landauer,
 ISSN = {00368733, 19467087},
 URL = {http://www.jstor.org/stable/24967723},
 author = {Charles H. Bennett and Rolf Landauer},
 journal = {Scientific American},
 number = {1},
 pages = {48--57},
 publisher = {Scientific American, a division of Nature America, Inc.},
 title = {The Fundamental Physical Limits of Computation},
 urldate = {2024-03-16},
 volume = {253},
 year = {1985}
}

@article{landauerIrreversibility,
  title = {Irreversibility and {{Heat Generation}} in the {{Computing Process}}},
  author = {Landauer, R.},
  year = {1961},
  month = jul,
  journal = {IBM Journal of Research and Development},
  volume = {5},
  number = {3},
  pages = {183--191},
  issn = {0018-8646},
  doi = {10.1147/rd.53.0183},
  urldate = {2024-03-16},
  abstract = {It is argued that computing machines inevitably involve devices which perform logical functions that do not have a single-valued inverse. This logical irreversibility is associated with physical irreversibility and requires a minimal heat generation, per machine cycle, typically of the order of kT for each irreversible function. This dissipation serves the purpose of standardizing signals and making them independent of their exact logical history. Two simple, but representative, models of bistable devices are subjected to a more detailed analysis of switching kinetics to yield the relationship between speed and energy dissipation, and to estimate the effects of errors induced by thermal fluctuations.},
  file = {/home/aidan/Zotero/storage/5836N27A/5392446.html}
}

@article{onComputableNumbers,
  title={On computable numbers, with an application to the Entscheidungsproblem},
  author={Turing, Alan Mathison and others},
  journal={J. of Math},
  volume={58},
  number={345-363},
  pages={5},
  year={1936}
}

@article{Lambda,
  title={A set of postulates for the foundation of logic},
  author={Church, Alonzo},
  journal={Annals of mathematics},
  pages={346--366},
  year={1932},
  publisher={JSTOR}
}

