@inproceedings{ReversibleMachineCode,
  title = {Reversible {{Machine Code}} and {{Its Abstract Processor Architecture}}},
  author = {Axelsen, Holger and Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
  year = {2007},
  month = sep,
  pages = {56--69},
  doi = {10.1007/978-3-540-74510-5_9},
  isbn = {978-3-540-74509-9}
}

@article{LogicalReversibility,
  title = {Logical {{Reversibility}} of {{Computation}}},
  author = {Bennett, C. H.},
  year = {1973},
  journal = {IBM Journal of Research and Development},
  volume = {17},
  number = {6},
  pages = {525--532},
  doi = {10.1147/rd.176.0525}
}

@inproceedings{SSAConstructionBraun,
  title = {Simple and {{Efficient Construction}} of {{Static Single Assignment Form}}},
  booktitle = {Compiler {{Construction}}},
  author = {Braun, Matthias and Buchwald, Sebastian and Hack, Sebastian and Lei{\ss}a, Roland and Mallon, Christoph and Zwinkau, Andreas},
  editor = {Jhala, Ranjit and De Bosschere, Koen},
  year = {2013},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {102--122},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-37051-9_6},
  abstract = {We present a simple SSA construction algorithm, which allows direct translation from an abstract syntax tree or bytecode into an SSA-based intermediate representation. The algorithm requires no prior analysis and ensures that even during construction the intermediate representation is in SSA form. This allows the application of SSA-based optimizations during construction. After completion, the intermediate representation is in minimal and pruned SSA form. In spite of its simplicity, the runtime of our algorithm is on par with Cytron~et~al.'s algorithm.},
  isbn = {978-3-642-37051-9},
  langid = {english},
  keywords = {Abstract Syntax Tree,Basic Block,Entry Block,Intermediate Representation,Strongly Connect Component},
}

@incollection{RIMP,
  title = {A {{Reversible Operational Semantics}} for {{Imperative Programming Languages}}},
  author = {Fern{\'a}ndez, Maribel and Mackie, Ian},
  year = {2020},
  month = dec,
  pages = {91--106},
  doi = {10.1007/978-3-030-63406-3_6},
  isbn = {978-3-030-63405-6}
}

@inproceedings{IntroductionToReversibleComputing,
  title = {Introduction to Reversible Computing: Motivation, Progress, and Challenges},
  shorttitle = {Introduction to Reversible Computing},
  booktitle = {Proceedings of the 2nd Conference on {{Computing}} Frontiers},
  author = {Frank, Michael P.},
  year = {2005},
  month = may,
  series = {{{CF}} '05},
  pages = {385--390},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1062261.1062324},
  urldate = {2023-11-29},
  abstract = {Reversible computing is motivated by the von Neumann-Landauer (VNL) principle, a theorem of modern physics telling us that ordinary irreversible logic operations (which destructively overwrite previous outputs) incur a fundamental minimum energy cost. Such operations typically dissipate roughly the logic signal energy, itself irreducible due to thermal noise. This fact threatens to end improvements in practical computer performance within the next few decades. However, computers based mainly on reversible logic operations can reuse a fraction of the signal energy that theoretically can approach arbitrarily near to 100\% as the quality of the hardware is improved, reopening the door to arbitrarily high computer performance at a given level of power dissipation. In the 32 years since the theoretical possibility of this approach was first shown by Bennett, our understanding of how to design and engineer practical machines based on reversible logic has improved dramatically, but a number of significant research challenges remain, e.g., (1) the development of fast and cheap switching devices with adiabatic energy coefficients well below those of transistors, (2) and of clocking systems that are themselves of very high reversible quality; and (3) the design of highly-optimized reversible logic circuits and algorithms. Finally, the field faces an uphill social battle in overcoming the enormous inertia of the established semiconductor industry, with its extreme resistance to revolutionary change. A more evolutionary strategy that aims to introduce reversible computing concepts only very gradually might well turn out to be more successful. This talk explains these basic issues, to set the stage for the rest of the workshop, which aims to address them in more detail},
  isbn = {978-1-59593-019-4},
  keywords = {computer architecture,digital logic technologies,field-effect devices,high-performance computing,limits of computing,low-power computing,power management,reversible computing,reversible logic,unconventional computing,VLSI},
}

@article{QuantumFoundations,
  title = {Quantum {{Foundations}} of {{Classical Reversible Computing}}},
  author = {Frank, Michael P. and Shukla, Karpur},
  year = {2021},
  journal = {Entropy},
  volume = {23},
  number = {6},
  issn = {1099-4300},
  doi = {10.3390/e23060701},
  abstract = {The reversible computation paradigm aims to provide a new foundation for general classical digital computing that is capable of circumventing the thermodynamic limits to the energy efficiency of the conventional, non-reversible digital paradigm. However, to date, the essential rationale for, and analysis of, classical reversible computing (RC) has not yet been expressed in terms that leverage the modern formal methods of non-equilibrium quantum thermodynamics (NEQT). In this paper, we begin developing an NEQT-based foundation for the physics of reversible computing. We use the framework of Gorini-Kossakowski-Sudarshan-Lindblad dynamics (a.k.a. Lindbladians) with multiple asymptotic states, incorporating recent results from resource theory, full counting statistics and stochastic thermodynamics. Important conclusions include that, as expected: (1) Landauer's Principle indeed sets a strict lower bound on entropy generation in traditional non-reversible architectures for deterministic computing machines when we account for the loss of correlations; and (2) implementations of the alternative reversible computation paradigm can potentially avoid such losses, and thereby circumvent the Landauer limit, potentially allowing the efficiency of future digital computing technologies to continue improving indefinitely. We also outline a research plan for identifying the fundamental minimum energy dissipation of reversible computing machines as a function of speed.}
}

@misc{PISAVM,
  title = {{{PendVM}}},
  author = {Haulund, Tue},
  year = {2018},
  journal = {GitHub repository},
  publisher = {{GitHub}}
}

@inproceedings{ReversibleArchitecture,
  title = {Towards a {{Unified Language Architecture}} for {{Reversible Object-Oriented Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {{Hay-Schmidt}, Lasse and Gl{\"u}ck, Robert and Cservenka, Martin Holm and Haulund, Tue},
  year = {2021},
  pages = {96--106},
  publisher = {{Springer International Publishing}},
  address = {{Cham}}
}

@article{Hermes,
  title = {Hermes: {{A}} Reversible Language for Lightweight Encryption},
  shorttitle = {Hermes},
  author = {Mogensen, Torben {\AE}gidius},
  year = {2022},
  month = mar,
  journal = {Science of Computer Programming},
  volume = {215},
  pages = {102746},
  issn = {0167-6423},
  doi = {10.1016/j.scico.2021.102746},
  urldate = {2023-12-10},
  abstract = {Hermes is a domain-specific language for writing lightweight encryption algorithms: It is reversible, so it is not necessary to write separate encryption and decryption procedures. Hermes uses a type system that avoids several types of side-channel attacks, by ensuring no secret values are left in memory and that operations on secret data spend time independent of the value of this data, thus preventing timing-based attacks. We show a complete formal specification of Hermes, argue absence of timing-based attacks (under reasonable assumptions), and compare implementations of well-known lightweight encryption algorithms in Hermes and C.},
  keywords = {Domain-specific languages,Lightweight encryption,Reversible programming languages,Side-channel attacks},
}

@incollection{hoeyCaseStudyReversible2020,
  title = {A {{Case Study}} for {{Reversible Computing}}: {{Reversible Debugging}} of {{Concurrent Programs}}},
  booktitle = {Reversible {{Computation}}: {{Extending Horizons}} of {{Computing}}: {{Selected Results}} of the {{COST Action IC1405}}},
  author = {Hoey, James and Lanese, Ivan and Nishida, Naoki and Ulidowski, Irek and Vidal, Germ{\'a}n},
  year = {2020},
  pages = {108--127},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-47361-7_5},
  isbn = {978-3-030-47361-7}
}

@book{IntroductionToReversibleComputingBook,
  title = {Introduction to {{Reversible Computing}}},
  author = {Perumalla, Kalyan S.},
  year = {2013},
  month = sep,
  publisher = {{CRC Press}},
  abstract = {Few books comprehensively cover the software and programming aspects of reversible computing. Filling this gap, Introduction to Reversible Computing offers an expanded view of the field that includes the traditional energy-motivated hardware viewpoint as well as the emerging application-motivated software approach.   Collecting scattered knowledge into one coherent account, the book provides a compendium of both classical and recently developed results on reversible computing. It explores up-and-coming theories, techniques, and tools for the application of reversible computing{\textemdash}the logical next step in the evolution of computing systems.  The book covers theory, hardware and software aspects, fundamental limits, complexity analyses, practical algorithms, compilers, efficiency improvement techniques, and application areas. The topics span several areas of computer science, including high-performance computing, parallel/distributed systems, computational theory, compilers, power-aware computing, and supercomputing.   The book presents sufficient material for newcomers to easily get started. It provides citations to original articles on seminal results so that readers can consult the corresponding publications in the literature. Pointers to additional resources are included for more advanced topics. For those already familiar with a certain topic within reversible computing, the book can serve as a one-stop reference to other topics in the field.},
  googlebooks = {HUrGAAAAQBAJ},
  isbn = {978-1-4398-7340-3},
  langid = {english},
  keywords = {Computers / General,Computers / Hardware / Mainframes \& Minicomputers,Computers / Programming / Algorithms,Mathematics / Advanced,Mathematics / Arithmetic,Mathematics / Number Systems}
}

@inproceedings{JanusFormalised,
  title={A reversible programming language and its invertible self-interpreter},
  author={Yokoyama, Tetsuo and Gl{\"u}ck, Robert},
  booktitle={Proceedings of the 2007 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
  pages={144--153},
  year={2007}
}


@unpublished{JanusLetter,
  type = {Letter},
  title = {{{JANUS}}: {{A Time-Reversible Language}}},
  author = {Christopher, Lutz},
  year = {1986},
  month = apr,
  urldate = {2023-12-01}
}

@inproceedings{JanusToRSSA,
  title = {Compiling {{Janus}} to {{RSSA}}},
  booktitle = {Reversible {{Computation}}},
  author = {Kutrib, Martin and Meyer, Uwe and Deworetzki, Niklas and Schuster, Marc},
  editor = {Yamashita, Shigeru and Yokoyama, Tetsuo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {64--78},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-79837-6_4},
  abstract = {Reversible programming languages have been a focus of research for more than the last decade mostly due to the work of Gl{\"u}ck, Yokoyama, Mogensen, and many others. In this paper, we report about our recent activities to compile code written in the reversible language Janus to reversible static-single-assignment form RSSA and to three-address-code, both of which can thereafter be compiled to C. In particular, this is {\textendash} to our knowledge {\textendash} the first compiler from Janus to RSSA. In addition, we have implemented a novel technique for a reversible compiler by executing the code generator itself in reverse. Our compiler provides the basis for optimizations and further analysis of reversible programs.},
  isbn = {978-3-030-79837-6},
  langid = {english},
  keywords = {Janus,Reverse computing,Reversible programming languages,Reversible static-single-assignment}
}

@article{LandauerLimit,
  title = {Irreversibility and {{Heat Generation}} in the {{Computing Process}}},
  author = {Landauer, R.},
  year = {1961},
  journal = {IBM Journal of Research and Development},
  volume = {5},
  number = {3},
  pages = {183--191},
  doi = {10.1147/rd.53.0183}
}

@article{LexingDerivatives,
  title = {{{POSIX Lexing}} with {{Derivatives}} of {{Regular Expressions}}},
  author = {Urban, Christian},
  year = {2023},
  month = jul,
  journal = {Journal of Automated Reasoning},
  volume = {67},
  number = {3},
  pages = {24},
  issn = {1573-0670},
  doi = {10.1007/s10817-023-09667-1},
  urldate = {2023-12-10},
  abstract = {Brzozowski introduced the notion of derivatives for regular expressions. They can be used for a very simple regular expression matching algorithm. Sulzmann and Lu cleverly extended this algorithm in order to deal with POSIX matching, which is the underlying disambiguation strategy for regular expressions needed in lexers. Their algorithm generates POSIX values which encode the information of how a regular expression matches a string{\textemdash}that is, which part of the string is matched by which part of the regular expression. In this paper we give our inductive definition of what a POSIX value is and show that Sulzmann and Lu's algorithm always generates such a value. We also show that our inductive definition of a POSIX value is equivalent to an alternative definition by Okui and Suzuki which identifies POSIX values as least elements according to an ordering of values.},
  langid = {english},
  keywords = {Derivatives of Regular Expressions,Isabelle/HOL,POSIX matching},
}

@article{LogicalReversibilityOfComputation,
  title = {Logical {{Reversibility}} of {{Computation}}},
  author = {Bennett, C. H.},
  year = {1973},
  month = nov,
  journal = {IBM Journal of Research and Development},
  volume = {17},
  number = {6},
  pages = {525--532},
  issn = {0018-8646},
  doi = {10.1147/rd.176.0525},
  urldate = {2023-12-01},
  abstract = {The usual general-purpose computing automaton (e.g., a Turing machine) is logically irreversible{\textemdash}its transition function lacks a single-valued inverse. Here it is shown that such machines may be made logically reversible at every step, while retaining their simplicity and their ability to do general computations. This result is of great physical interest because it makes plausible the existence of thermodynamically reversible computers which could perform useful computations at useful speed while dissipating considerably less than kT of energy per logical step. In the first stage of its computation the logically reversible automaton parallels the corresponding irreversible automaton, except that it saves all intermediate results, thereby avoiding the irreversible operation of erasure. The second stage consists of printing out the desired output. The third stage then reversibly disposes of all the undesired intermediate results by retracing the steps of the first stage in backward order (a process which is only possible because the first stage has been carried out reversibly), thereby restoring the machine (except for the now-written output tape) to its original condition. The final machine configuration thus contains the desired output and a reconstructed copy of the input, but no other undesired data. The foregoing results are demonstrated explicitly using a type of three-tape Turing machine. The biosynthesis of messenger RNA is discussed as a physical example of reversible computation.},
}


@misc{NFAConstruction,
  title = {Gluskov and {{Thompson}} Constructions : A Synthesis},
  shorttitle = {Gluskov and {{Thompson}} Constructions},
  author = {Giammarresi, Dora},
  year = {1998},
  langid = {english}
}

@inproceedings{OptimiseReversiblePrograms,
  title = {Optimizing {{Reversible Programs}}},
  booktitle = {Reversible {{Computation}}},
  author = {Deworetzki, Niklas and Kutrib, Martin and Meyer, Uwe and Ritzke, Pia-Doreen},
  editor = {Mezzina, Claudio Antares and Podlaski, Krzysztof},
  year = {2022},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {224--238},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-031-09005-9_16},
  abstract = {Reversible programming languages have been a focus of research for more than the last decade mostly due to the work of Gl{\"u}ck, Yokoyama, Mogensen, and many others. In this paper we report about our recent activities to optimize reversible code with respect to execution time. Based on our rc3-compiler which compiles Janus to reversible static-single-assignment form RSSA, we had explored and implemented optimization algorithms for local common-subexpression elimination, constant propagation, and folding and have presented those at SOAP 2021. This paper focuses on new achievements for procedure inlining as well as elimination of dead code. Our compiler is{\textemdash}to our knowledge{\textemdash}the first optimizing compiler for reversible languages. Whereas these optimizations are well established for ``traditional'' languages, programs that can be executed forwards and backwards require different and novel approaches.},
  isbn = {978-3-031-09005-9},
  langid = {english},
  keywords = {Janus,Optimization,Reverse computing,Reversible programming languages,Reversible static-single-assignment},
}

@inproceedings{ReversibleStudy,
  title = {A {{Certified Study}} of a {{Reversible Programming Language}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{TYPES}}.2015.7},
  author = {Paolini, Luca and Piccolo, Mauro and Roversi, Luca},
  year = {2018},
  publisher = {{Schloss-Dagstuhl - Leibniz Zentrum f{\"u}r Informatik}},
  doi = {10.4230/LIPIcs.TYPES.2015.7},
  urldate = {2023-12-10},
  abstract = {We advance in the study of the semantics of Janus, a C-like reversible programming language.  Our study makes utterly explicit some backward and forward evaluation symmetries. We want to deepen mathematical knowledge about the foundations and design principles of reversible computing and programming languages. We formalize a big-step operational semantics and a denotational semantics of Janus. We show a full abstraction result between the operational and denotational semantics. Last, we certify our results by means of the proof assistant Matita.},
  copyright = {https://creativecommons.org/licenses/by/3.0/legalcode},
  langid = {english},
}

@incollection{PISA,
  title = {Reversible {{Machine Code}} and {{Its Abstract Processor Architecture}}},
  booktitle = {Computer {{Science}} {\textendash} {{Theory}} and {{Applications}}},
  author = {Axelsen, Holger Bock and Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
  editor = {Diekert, Volker and Volkov, Mikhail V. and Voronkov, Andrei},
  year = {2007},
  volume = {4649},
  pages = {56--69},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-74510-5_9},
  urldate = {2023-12-01},
  abstract = {A reversible abstract machine architecture and its reversible machine code are presented and formalized. For machine code to be reversible, both the underlying control logic and each instruction must be reversible. A general class of machine instruction sets was proven to be reversible, building on our concept of reversible updates. The presentation is abstract and can serve as a guideline for a family of reversible processor designs. By example, we illustrate programming principles for the abstract machine architecture formalized in this paper.},
  isbn = {978-3-540-74509-9 978-3-540-74510-5},
  langid = {english},
}

@inproceedings{PrattParsing,
  title = {Top down Operator Precedence},
  booktitle = {Proceedings of the 1st Annual {{ACM SIGACT-SIGPLAN}} Symposium on {{Principles}} of Programming Languages  - {{POPL}} '73},
  author = {Pratt, Vaughan R.},
  year = {1973},
  pages = {41--51},
  publisher = {{ACM Press}},
  address = {{Boston, Massachusetts}},
  doi = {10.1145/512927.512931},
  urldate = {2023-12-10},
  langid = {english},
}

@inproceedings{PrinciplesOfReversibleProgrammingLanguage,
  title = {Principles of a Reversible Programming Language},
  booktitle = {Proceedings of the 5th Conference on {{Computing}} Frontiers},
  author = {Yokoyama, Tetsuo and Axelsen, Holger Bock and Gl{\"u}ck, Robert},
  year = {2008},
  month = may,
  series = {{{CF}} '08},
  pages = {43--54},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1366230.1366239},
  urldate = {2023-12-10},
  abstract = {The principles of reversible programming languages are explicated and illustrated with reference to the design of a high-level imperative language, Janus. The fundamental properties for such languages include backward as well as forward determinism and reversible updates of data. The unique design features of the language include explicit post-condition assertions, direct access to an inverse semantics and the possibility of clean (\{{\textbackslash}ie\}, garbage-free) computation of injective functions. We suggest the clean simulation of reversible Turing machines as a criterion for computing strength of reversible languages, and demonstrate this for Janus. We show the practicality of the language by implementation of a reversible fast Fourier transform. Our results indicate that the reversible programming paradigm has fundamental properties that are relevant to many different areas of computer science.},
  isbn = {978-1-60558-077-7},
  keywords = {backward determinism,fast fourier transform,inverse semantics,reversible computing,turing completeness}
}

@article{ReversibilityWithMinimalData,
  title = {Making {{Programs Reversible}} with {{Minimal Extra Data}}},
  author = {Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
  year = {2022},
  month = jul,
  journal = {New Generation Computing},
  volume = {40},
  number = {2},
  pages = {467--480},
  issn = {1882-7055},
  doi = {10.1007/s00354-022-00169-z},
  urldate = {2023-12-10},
  abstract = {Reversible computing is an unconventional computing paradigm that comes with specific challenges. One of the important questions is the existence of reversible programs with minimal extra output (garbage data). To answer this question for programs that implement partial functions over countable domains, we introduce an order on infinite garbage sets and a notion of minimality. To this end, we present two methods for functions specified by decidable and semi-decidable predicates. Both methods are universal, which means they work for all programs specified by the predicates. They cover Bennett's classic input-erasing reversible computation of injective functions. Hence, any program written in a Turing-complete programming language can be implemented with g-minimal garbage in an r-Turing-complete reversible programming language. This generality comes at the cost of a considerable runtime due to the generate-and-test approach.},
  langid = {english},
  keywords = {68Q30,68W40,Garbage data,Injectivization,Reversibilization,Reversible computing,Reversible programming}
}

@inproceedings{ReversibleArrayProgramming,
  title = {Reversible {{Functional Array Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {Mogensen, Torben {\AE}gidius},
  editor = {Yamashita, Shigeru and Yokoyama, Tetsuo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {45--63},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-79837-6_3},
  abstract = {Functional array programming is a style of programming that enables massive parallelism through use of combinators (such as map and reduce) that apply functions to whole arrays. These can be readily parallelised when the functions these combinators are applied to are pure and, in some cases, also associative.},
  isbn = {978-3-030-79837-6},
  langid = {english}
}

@article{ReversibleMetalanguages,
  title = {From Reversible Programming Languages to Reversible Metalanguages},
  author = {Gl{\"u}ck, Robert and Kaarsgaard, Robin and Yokoyama, Tetsuo},
  year = {2022},
  month = jun,
  journal = {Theoretical Computer Science},
  volume = {920},
  pages = {46--63},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2022.02.024},
  urldate = {2023-12-10},
  abstract = {During the past decade reversible programming languages have been formalized using various established semantics frameworks. However, these semantics fail to effectively specify the distinct properties of reversible languages at the metalevel, even including the central question of whether the defined language is reversible. In this paper, we build a metalanguage foundation for reversible languages from categorical principles, based on the category of sets and partial injective functions. We exemplify our approach by a step-by-step development of the full semantics of an r-Turing complete reversible while-language with recursive procedures. The use of the metalanguage leads to a formalization of the reversible semantics. A language defined in the metalanguage is guaranteed to have reversibility and inverse semantics. Also, program inverters for this language are obtained for free. We further discuss applications and directions for reversible semantics.},
  keywords = {Formal semantics,Iteration,Partial injective functions,Recursion,Reversible programming},
}

@inproceedings{ReversiblePrologDebugger,
  title = {Reversible {{Computations}} in {{Logic Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {Vidal, Germ{\'a}n},
  editor = {Lanese, Ivan and Rawski, Mariusz},
  year = {2020},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {246--254},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-52482-1_15},
  abstract = {In this work, we say that a computation is reversible if one can find a procedure to undo the steps of a standard (or forward) computation in a deterministic way. While logic programs are often invertible (e.g., one can use the same predicate for adding and for subtracting natural numbers), computations are not reversible in the above sense. In this paper, we present a so-called Landauer embedding for SLD resolution, the operational principle of logic programs, so that it becomes reversible. A proof-of-concept implementation of a reversible debugger for Prolog that follows the ideas in this paper has been developed and is publicly available.},
  isbn = {978-3-030-52482-1},
  langid = {english},
}

@inproceedings{RFunInterpreter,
  title = {Interpretation and Programming of the Reversible Functional Language {{RFUN}}},
  booktitle = {Proceedings of the 27th {{Symposium}} on the {{Implementation}} and {{Application}} of {{Functional Programming Languages}}},
  author = {Thomsen, Michael Kirkedal and Axelsen, Holger Bock},
  year = {2015},
  month = sep,
  series = {{{IFL}} '15},
  pages = {1--13},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2897336.2897345},
  urldate = {2023-12-10},
  abstract = {rfun is a small first-order reversible functional language introduced by Yokoyama et al. in 2012. The present paper aims to further the understanding of reversible functional programming (and RFUN in particular) by describing implementations in, and of, the RFUN language. After briefly summarizing rfun in terms of syntax and semantics, we first (informally) describe a transformation from the simple irreversible first-order language fun to rfun. This highlights how irreversibility is avoided in rfun, such as in the use of the so-called first-match policy. It also emphasizes the fact that rfun is trace-less, while also showing how the standard reversible (trace-full) embeddings of Landauer and Bennett can be implemented. Second, we outline (by examples) a number of the reversible functions that have been implemented in rfun. The programming examples given here focus on Peano arithmetic and list functions, and are intended to show various useful programming techniques of the reversible functional programming paradigm. Finally, we discuss the implementation of rfun. This is twofold as we relate a Haskell implementation of an rfun interpreter, to an implementation of a self-interpreter, i.e., an rfun interpreter implemented in rfun. Although rfun does not have the rich and expressive syntax of Haskell---which makes programming the self-interpreter more cumbersome in some aspects---the built-in support for reverse execution greatly reduces the code base and makes the rfun-based self-interpreter implementation follow the formal semantics of rfun more directly than the Haskell-based interpreter.},
  isbn = {978-1-4503-4273-5},
  keywords = {functional programming languages,program transformation,reversibilization,reversible computing,reversible functional programming,self-interpretation}
}

@book{richardpFeynmanLecturesComputation2018,
  title = {Feynman Lectures on Computation},
  author = {Richard P, Feynman},
  year = {2018},
  publisher = {{CRC Press}}
}

@inproceedings{ROOP,
  title = {Towards a {{Unified Language Architecture}} for {{Reversible Object-Oriented Programming}}},
  booktitle = {Reversible {{Computation}}},
  author = {{Hay-Schmidt}, Lasse and Gl{\"u}ck, Robert and Cservenka, Martin Holm and Haulund, Tue},
  editor = {Yamashita, Shigeru and Yokoyama, Tetsuo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {96--106},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-79837-6_6},
  abstract = {A unified language architecture for an advanced reversible object-oriented language is described. The design and implementation choices made for a tree-walking interpreter and source-language inverter are discussed, as well as the integration with an existing monadic parser, type checker and PISA compiler backend. A demonstration of the web interface and the interactions required to interpret, compile and invert reversible object-oriented programs is given. Our aim is that this platform will make reversible programming approachable to a wider community.},
  isbn = {978-3-030-79837-6},
  langid = {english},
}

@misc{ROOPImplementation,
  title = {Design and {{Implementation}} of a {{Reversible Object-Oriented Programming Language}}},
  author = {Haulund, Tue},
  year = {2017},
  month = jul,
  number = {arXiv:1707.07845},
  eprint = {1707.07845},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.1707.07845},
  urldate = {2023-12-01},
  abstract = {High-level reversible programming languages are few and far between and in general offer only rudimentary abstractions from the details of the underlying machine. Modern programming languages offer a wide array of language constructs and paradigms to facilitate the design of abstract interfaces, but we currently have a very limited understanding of the applicability of such features for reversible programming languages. We introduce the first reversible object-oriented programming language, ROOPL, with support for user-defined data types, class inheritance and subtype-polymorphism. The language extends the design of existing reversible imperative languages and it allows for effective implementation on reversible machines. We provide a formalization of the language semantics, the type system and we demonstrate the computational universality of the language by implementing a reversible Turing machine simulator. ROOPL statements are locally invertible at no extra cost to program size or computational complexity and the language provides direct access to the inverse semantics of each class method. We describe the techniques required for a garbage-free translation from ROOPL to the reversible assembly language PISA and provide a full implementation of said techniques. Our results indicate that core language features for object-oriented programming carries over to the field of reversible computing in some capacity.},
  archiveprefix = {arxiv},
  keywords = {68N15,Computer Science - Programming Languages,D.3.2,D.3.3,D.3.4},
}

@inproceedings{RSSA,
  title = {{{RSSA}}: {{A Reversible SSA Form}}},
  shorttitle = {{{RSSA}}},
  booktitle = {Perspectives of {{System Informatics}}},
  author = {Mogensen, Torben {\AE}gidius},
  editor = {Mazzara, Manuel and Voronkov, Andrei},
  year = {2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {203--217},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-41579-6_16},
  abstract = {The SSA form (Static Single Assignment form) is used in compilers as an intermediate language as an alternative to traditional three-address code because code in SSA form is easier to analyse and optimize using data-flow analysis such as common-subexpression elimination, value numbering, register allocation and so on.},
  isbn = {978-3-319-41579-6},
  langid = {english},
  keywords = {Basic Block,Constant Propagation,Entry Point,Exit Point,Result List},
}

@article{SourceCodeTransformationsEfficient,
  title={Source-code transformations for efficient reversibility},
  author={Perumalla, Kalyan S and Fujimoto, Richard M},
  year={1999},
  publisher={Georgia Institute of Technology}
}


@inproceedings{SSA,
  title = {Global Value Numbers and Redundant Computations},
  booktitle = {Proceedings of the 15th {{ACM SIGPLAN-SIGACT}} Symposium on {{Principles}} of Programming Languages},
  author = {Rosen, B. K. and Wegman, M. N. and Zadeck, F. K.},
  year = {1988},
  month = jan,
  series = {{{POPL}} '88},
  pages = {12--27},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/73560.73562},
  urldate = {2023-12-10},
  isbn = {978-0-89791-252-5},
}

@article{SSAConstruction,
  title = {Algorithms for Computing the Static Single Assignment Form},
  author = {Bilardi, Gianfranco and Pingali, Keshav},
  year = {2003},
  month = may,
  journal = {Journal of the ACM},
  volume = {50},
  number = {3},
  pages = {375--425},
  issn = {0004-5411},
  doi = {10.1145/765568.765573},
  urldate = {2023-12-10},
  abstract = {The Static Single Assignment (SSA) form is a program representation used in many optimizing compilers. The key step in converting a program to SSA form is called {$\phi$}-placement. Many algorithms for {$\phi$}-placement have been proposed in the literature, but the relationships between these algorithms are not well understood.In this article, we propose a framework within which we systematically derive (i) properties of the SSA form and (ii) {$\phi$}-placement algorithms. This framework is based on a new relation called merge which captures succinctly the structure of a program's control flow graph that is relevant to its SSA form. The {$\phi$}-placement algorithms we derive include most of the ones described in the literature, as well as several new ones. We also evaluate experimentally the performance of some of these algorithms on the SPEC92 benchmarks.Some of the algorithms described here are optimal for a single variable. However, their repeated application is not necessarily optimal for multiple variables. We conclude the article by describing such an optimal algorithm, based on the transitive reduction of the merge relation, for multi-variable {$\phi$}-placement in structured programs. The problem for general programs remains open.},
  keywords = {Control dependence,optimizing compilers,program optimization,program transformation,static single assignment form},
}

@incollection{SSAFromAST,
  title = {Simple and {{Efficient Construction}} of {{Static Single Assignment Form}}},
  booktitle = {Compiler {{Construction}}},
  author = {Braun, Matthias and Buchwald, Sebastian and Hack, Sebastian and Lei{\ss}a, Roland and Mallon, Christoph and Zwinkau, Andreas},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Jhala, Ranjit and De Bosschere, Koen},
  year = {2013},
  volume = {7791},
  pages = {102--122},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-37051-9_6},
  urldate = {2023-12-01},
  abstract = {We present a simple SSA construction algorithm, which allows direct translation from an abstract syntax tree or bytecode into an SSA-based intermediate representation. The algorithm requires no prior analysis and ensures that even during construction the intermediate representation is in SSA form. This allows the application of SSA-based optimizations during construction. After completion, the intermediate representation is in minimal and pruned SSA form. In spite of its simplicity, the runtime of our algorithm is on par with Cytron et al.'s algorithm.},
  isbn = {978-3-642-37050-2 978-3-642-37051-9},
  langid = {english},
}

@inproceedings{yokoyamaReversibleProgrammingLanguage2007,
  title = {A {{Reversible Programming Language}} and {{Its Invertible Self-Interpreter}}},
  booktitle = {Proceedings of the 2007 {{ACM SIGPLAN Symposium}} on {{Partial Evaluation}} and {{Semantics-Based Program Manipulation}}},
  author = {Yokoyama, Tetsuo and Gl{\"u}ck, Robert},
  year = {2007},
  series = {{{PEPM}} '07},
  pages = {144--153},
  publisher = {{Association for Computing Machinery}},
  doi = {10.1145/1244381.1244404},
  isbn = {978-1-59593-620-2}
}

@article{KnuthLRParsing,
  title = {On the translation of languages from left to right},
  journal = {Information and Control},
  volume = {8},
  number = {6},
  pages = {607-639},
  year = {1965},
  issn = {0019-9958},
  doi = {https://doi.org/10.1016/S0019-9958(65)90426-2},
  author = {Donald E. Knuth},
  abstract = {There has been much recent interest in languages whose grammar is sufficiently simple that an efficient left-to-right parsing algorithm can be mechanically produced from the grammar. In this paper, we define LR(k) grammars, which are perhaps the most general ones of this type, and they provide the basis for understanding all of the special tricks which have been used in the construction of parsing algorithms for languages with simple structure, e.g. algebraic languages. We give algorithms for deciding if a given grammar satisfies the LR(k) condition, for given k, and also give methods for generating recognizes for LR(k) grammars. It is shown that the problem of whether or not a grammar is LR(k) for some k is undecidable, and the paper concludes by establishing various connections between LR(k) grammars and deterministic languages. In particular, the LR(k) condition is a natural analogue, for grammars, of the deterministic condition, for languages.}
}

@article{M4,
  title={The M4 Macro Processor Brian W. Kernighan},
  author={Ritchie, Dennis M},
  year={1977}
}

@inproceedings{RFun,
  title={Towards a reversible functional language},
  author={Yokoyama, Tetsuo and Axelsen, Holger Bock and Gl{\"u}ck, Robert},
  booktitle={International Workshop on Reversible Computation},
  pages={14--29},
  year={2011},
  organization={Springer}
}

@inproceedings{debug,
  title={A review of reverse debugging},
  author={Engblom, Jakob},
  booktitle={Proceedings of the 2012 System, Software, SoC and Silicon Debug Conference},
  pages={1--6},
  year={2012},
  organization={IEEE}
}

@article{Derivatives,
  title={Derivatives of regular expressions},
  author={Brzozowski, Janusz A},
  journal={Journal of the ACM (JACM)},
  volume={11},
  number={4},
  pages={481--494},
  year={1964},
  publisher={ACM New York, NY, USA}
}

@inproceedings{Compiler,
  author = {Hopper, Grace Murray},
  title = {The Education of a Computer},
  year = {1952},
  isbn = {9781450373623},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/609784.609818},
  doi = {10.1145/609784.609818},
  abstract = {While the materialization is new, the idea of mechanizing mathematical thinking is not new. Its lineage starts with the abacus and descends through Pascal,Leibnitz, and Babbage. More immediately, the ideas here presented originate from Professor Howard H. Aiken of Harvard University, Dr. John W. Mauchly of Eckert-Mauchly and Dr. M. V. Wilkes of the University of Cambridge. From Professor Aiken came, in 1946, the idea of a library of routines described in the Mark I manual, and the concepts embodied in the Mark III coding machine, from Dr. Mauchly, the basic principles of the "short-order code" and suggestions, criticisms, and untiring patience in listening to these present attempts; from Dr. Wilkes, the greatest help of all, a book on the subject. For those of their ideas which are included herein, I most earnestly express my debt and my appreciation.},
  booktitle = {Proceedings of the 1952 ACM National Meeting (Pittsburgh)},
  pages = {243–249},
  numpages = {7},
  location = {Pittsburgh, Pennsylvania},
  series = {ACM '52}
}

@inproceedings{Sulzmann,
  author = {Sulzmann, Martin and Lu, Kenny Zhuo Ming},
  year = {2014},
  month = {06},
  pages = {},
  title = {POSIX Regular Expression Parsing with Derivatives},
  isbn = {978-3-319-07150-3},
  doi = {10.1007/978-3-319-07151-0_13}
}


@inproceedings{Okui,
  title={Disambiguation in regular expression matching via position automata with augmented transitions},
  author={Okui, Satoshi and Suzuki, Taro},
  booktitle={Implementation and Application of Automata: 15th International Conference, CIAA 2010, Winnipeg, MB, Canada, August 12-15, 2010. Revised Selected Papers 15},
  pages={231--240},
  year={2011},
  organization={Springer}
}

@inproceedings{topdownparse,
  title={Modular and efficient top-down parsing for ambiguous left-recursive grammars},
  author={Frost, Richard and Hafiz, Rahmatullah and Callaghan, Paul},
  booktitle={Proceedings of the Tenth International Conference on Parsing Technologies},
  pages={109--120},
  year={2007}
}

@inproceedings{parsercombinators,
  title={Parser combinators for ambiguous left-recursive grammars},
  author={Frost, Richard A and Hafiz, Rahmatullah and Callaghan, Paul},
  booktitle={Practical Aspects of Declarative Languages: 10th International Symposium, PADL 2008, San Francisco, CA, USA, January 7-8, 2008. Proceedings 10},
  pages={167--181},
  year={2008},
  organization={Springer}
}

@article{combiningOptimisation,
  title={Combining analyses, combining optimizations},
  author={Click, Cliff and Cooper, Keith D},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={17},
  number={2},
  pages={181--196},
  year={1995},
  publisher={ACM New York, NY, USA}
}

@article{constantProp,
  title={Constant propagation with conditional branches},
  author={Wegman, Mark N and Zadeck, F Kenneth},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={13},
  number={2},
  pages={181--210},
  year={1991},
  publisher={ACM New York, NY, USA}
}

